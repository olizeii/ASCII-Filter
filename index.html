<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<title>Desktop → ASCII Overlay</title>
<style>
  html, body { margin:0; height:100%; background:#000; }

  pre#ascii {
    position: fixed; inset: 0;
    margin: 0;
    color: #fff;
    font-family: "Consolas", "DejaVu Sans Mono", monospace;
    font-size: 10px;     /* will be adjusted by JS (auto or fixed px) */
    line-height: 0.9em;  /* tight-ish, helps aspect ratio */
    white-space: pre;
    letter-spacing: 0;
    user-select: none;
    pointer-events: none;
  }

  .hud {
    position: fixed; left: 8px; top: 8px;
    color: #0f0;
    font: 12px/1 monospace;
    opacity: 0.8;
    pointer-events: none;
    text-shadow: 0 0 4px #000;
  }
</style>
</head>
<body>
  <pre id="ascii">Starte…</pre>
  <div class="hud" id="hud"></div>

<script>
  const { desktopCapturer } = require('electron');

  const ASCII = " .:-=+*#%@";
  const MAX_FPS = 30;

  const pre = document.getElementById('ascii');
  const hud = document.getElementById('hud');

  // Offscreen canvas for downscaling
  const c = document.createElement('canvas');
  const ctx = c.getContext('2d', { willReadFrequently: true });

  // Read rectangles (DIP) + size from URL
  const q = new URLSearchParams(location.search);
  const BX = +q.get('bx'), BY = +q.get('by'), BW = +q.get('bw'), BH = +q.get('bh');
  const WX = +q.get('wx'), WY = +q.get('wy'), WW = +q.get('ww'), WH = +q.get('wh');
  const sizeParamRaw = (q.get('s') || 'auto').toLowerCase();
  const sizePx = /^\d+$/.test(sizeParamRaw) ? parseInt(sizeParamRaw, 10) : null;
  const sizeMode = sizePx ? 'fixed' : 'auto';

  function grayToChar(g) {
    return ASCII[Math.floor(g * (ASCII.length - 1) / 255)];
  }

  function applyFont() {
    if (sizeMode === 'fixed') {
      pre.style.fontSize = sizePx + 'px';
      // keep line-height tied to font-size for stable cell height
      pre.style.lineHeight = Math.max(1, Math.round(sizePx * 0.9)) + 'px';
    } else {
      // auto: pick a reasonable default; grid still adapts to window
      const base = Math.max(8, Math.min(14, Math.round(Math.min(window.innerWidth, window.innerHeight) / 90)));
      pre.style.fontSize = base + 'px';
      pre.style.lineHeight = Math.max(1, Math.round(base * 0.9)) + 'px';
    }
  }

  function measureChar() {
    // Measure the actual character cell in CSS pixels (DIP)
    const test = document.createElement('span');
    test.textContent = '0'.repeat(200);
    const cs = getComputedStyle(pre);
    test.style.fontFamily = cs.fontFamily;
    test.style.fontSize = cs.fontSize;
    test.style.lineHeight = cs.lineHeight;
    test.style.position = 'absolute';
    test.style.visibility = 'hidden';
    test.style.whiteSpace = 'nowrap';
    document.body.appendChild(test);
    const total = test.getBoundingClientRect();
    document.body.removeChild(test);
    const charW = total.width / 200;
    const charH = parseFloat(cs.lineHeight);
    return { charW, charH };
  }

  function recalcGrid() {
    const { charW, charH } = measureChar();
    const cols = Math.max(1, Math.floor(window.innerWidth / charW));
    const rows = Math.max(1, Math.floor(window.innerHeight / charH));
    c.width = cols;
    c.height = rows;
    return { cols, rows };
  }

  async function getScreenStream() {
    const sources = await desktopCapturer.getSources({ types: ['screen'] });
    const source = sources[0];
    return await navigator.mediaDevices.getUserMedia({
      audio: false,
      video: {
        mandatory: {
          chromeMediaSource: 'desktop',
          chromeMediaSourceId: source.id,
          maxFrameRate: MAX_FPS
        },
        cursor: 'never' // Do not capture mouse pointer (avoid "ghost cursor")
      }
    });
  }

  async function start() {
    try {
      applyFont();
      let { cols, rows } = recalcGrid();

      const stream = await getScreenStream();

      const video = document.createElement('video');
      video.srcObject = stream;
      video.muted = true;
      await video.play();

      // Compute crop to workArea in video pixels
      const scaleX = video.videoWidth / BW;
      const scaleY = video.videoHeight / BH;
      const crop = {
        sx: (WX - BX) * scaleX,
        sy: (WY - BY) * scaleY,
        sw: WW * scaleX,
        sh: WH * scaleY
      };

      // Recompute on window resize
      window.addEventListener('resize', () => {
        if (sizeMode === 'auto') applyFont();
        const r = recalcGrid();
        cols = r.cols; rows = r.rows;
      });

      let frames = 0, lastFpsT = performance.now();

      function loop(now) {
        // Draw ONLY the work area (no taskbar) → scale to ASCII grid size
        ctx.drawImage(video, crop.sx, crop.sy, crop.sw, crop.sh, 0, 0, c.width, c.height);
        const data = ctx.getImageData(0, 0, c.width, c.height).data;

        // Map to ASCII
        let out = '';
        for (let y = 0, i = 0; y < c.height; y++) {
          for (let x = 0; x < c.width; x++, i += 4) {
            const gray = (data[i]*299 + data[i+1]*587 + data[i+2]*114) / 1000;
            out += grayToChar(gray);
          }
          out += '\n';
        }
        pre.textContent = out;

        frames++;
        if (now - lastFpsT > 500) {
          const fps = Math.round(frames * 1000 / (now - lastFpsT));
          const cs = getComputedStyle(pre);
          const sizeLbl = sizeMode === 'auto' ? 'auto' : `${parseFloat(cs.fontSize)}px`;
          hud.textContent = `ASCII ${c.width}x${c.height} | size: ${sizeLbl} | ~${fps} FPS`;
          frames = 0;
          lastFpsT = now;
        }

        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);

    } catch (e) {
      pre.textContent = 'Fehler/Permission: ' + e;
    }
  }

  start();
</script>
</body>
</html>
